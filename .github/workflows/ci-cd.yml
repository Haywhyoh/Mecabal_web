name: CI/CD

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]
  workflow_dispatch: # Allow manual triggering
  schedule:
    # Run SSL renewal on the 1st of every month at 2 AM UTC
    - cron: '0 2 1 * *'

env:
  DOCKER_IMAGE_NAME: mecabal-web-app
  DOCKER_IMAGE_TAG: ${{ github.sha }}

jobs:
  # CI: Run on all pushes and PRs
  ci:
    name: Continuous Integration
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [20.x]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint
        # Lint script exits with 0 even if warnings are found (warnings are non-blocking)

      - name: Build project
        run: npm run build
        env:
          NODE_ENV: production

      - name: Check build artifacts
        run: |
          if [ ! -d ".next" ]; then
            echo "Build failed: .next directory not found"
            exit 1
          fi
          echo "Build successful! Build artifacts found in .next directory"

  # Deployment: Only run on pushes to main (not on PRs)
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: ci  # Only deploy if CI passes
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub (if using registry)
        if: env.DOCKER_REGISTRY == 'dockerhub'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: ${{ env.DOCKER_REGISTRY == 'dockerhub' }}
          tags: |
            ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_IMAGE_TAG }}
            ${{ env.DOCKER_IMAGE_NAME }}:latest
          build-args: |
            NEXT_PUBLIC_GOOGLE_CLIENT_ID=${{ secrets.NEXT_PUBLIC_GOOGLE_CLIENT_ID }}
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
            NEXT_PUBLIC_APP_URL=${{ secrets.NEXT_PUBLIC_APP_URL }}
            NEXT_PUBLIC_ENVIRONMENT=production
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Deploy to production server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          port: ${{ secrets.PRODUCTION_SSH_PORT || 22 }}
          script: |
            set -e
            
            # Determine project directory
            PROJECT_DIR="${{ secrets.PRODUCTION_WEB_APP_PATH }}"
            if [ -z "$PROJECT_DIR" ]; then
              # Try to detect common locations
              if [ -d "/root/Mecabal_web" ]; then
                PROJECT_DIR="/root/Mecabal_web"
              elif [ -d "/opt/mecabal/web-app" ]; then
                PROJECT_DIR="/opt/mecabal/web-app"
              else
                echo "ERROR: Could not determine project directory. Set PRODUCTION_WEB_APP_PATH secret."
                exit 1
              fi
            fi
            
            echo "Using project directory: $PROJECT_DIR"
            cd "$PROJECT_DIR" || {
              echo "ERROR: Project directory not found: $PROJECT_DIR"
              exit 1
            }
            
            # Verify we're in the right directory
            if [ ! -f "Dockerfile" ] && [ ! -f "docker-compose.production.yml" ]; then
              echo "ERROR: Does not appear to be a valid project directory"
              exit 1
            fi
            
            # Pull latest code (if not using Docker registry)
            if [ "${{ env.DOCKER_REGISTRY }}" != "dockerhub" ]; then
              git fetch origin
              git reset --hard origin/main
            fi
            
            # Ensure Docker network exists
            docker network inspect mecabal_mecabal-network >/dev/null 2>&1 || \
              docker network create mecabal_mecabal-network
            
            # Stop existing container gracefully
            if [ "$(docker ps -q -f name=mecabal-web-app)" ]; then
              echo "Stopping existing container..."
              docker stop mecabal-web-app || true
              docker rm mecabal-web-app || true
            fi
            
            # Pull image if using registry, otherwise build locally
            if [ "${{ env.DOCKER_REGISTRY }}" == "dockerhub" ]; then
              docker pull ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_IMAGE_TAG }} || true
              docker tag ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_IMAGE_TAG }} ${{ env.DOCKER_IMAGE_NAME }}:latest
            else
              # Load environment variables from .env.production
              if [ -f ".env.production" ]; then
                echo "Loading environment variables from .env.production..."
                set -a
                source .env.production
                set +a
              else
                echo "WARNING: .env.production not found. Build args may be missing."
              fi
              
              # Build image locally on server with build args from .env.production
              echo "Building Docker image with environment variables..."
              docker build \
                --build-arg NEXT_PUBLIC_GOOGLE_CLIENT_ID="${NEXT_PUBLIC_GOOGLE_CLIENT_ID:-}" \
                --build-arg NEXT_PUBLIC_API_URL="${NEXT_PUBLIC_API_URL:-}" \
                --build-arg NEXT_PUBLIC_APP_URL="${NEXT_PUBLIC_APP_URL:-}" \
                --build-arg NEXT_PUBLIC_ENVIRONMENT="${NEXT_PUBLIC_ENVIRONMENT:-production}" \
                -t ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_IMAGE_TAG }} \
                -t ${{ env.DOCKER_IMAGE_NAME }}:latest \
                -f Dockerfile .
            fi
            
            # Start new container
            echo "Starting new container..."
            docker-compose -f docker-compose.production.yml up -d --build
            
            # Wait for health check
            echo "Waiting for container to be healthy..."
            timeout=60
            counter=0
            while [ $counter -lt $timeout ]; do
              if docker exec mecabal-web-app node -e "require('http').get('http://localhost:3015', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})" 2>/dev/null; then
                echo "Container is healthy!"
                break
              fi
              sleep 2
              counter=$((counter + 2))
            done
            
            if [ $counter -ge $timeout ]; then
              echo "Container health check failed!"
              docker logs mecabal-web-app --tail 50
              exit 1
            fi
            
            # Clean up old images (keep last 3)
            echo "Cleaning up old Docker images..."
            docker image prune -f
            docker images ${{ env.DOCKER_IMAGE_NAME }} --format "{{.ID}} {{.Tag}}" | \
              grep -v latest | \
              tail -n +4 | \
              awk '{print $1}' | \
              xargs -r docker rmi -f || true
            
            # Reload nginx if it exists
            if docker ps -q -f name=mecabal-nginx >/dev/null 2>&1; then
              echo "Reloading nginx..."
              docker exec mecabal-nginx nginx -s reload || true
            fi
            
            echo "Deployment completed successfully!"

      - name: Verify deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          port: ${{ secrets.PRODUCTION_SSH_PORT || 22 }}
          script: |
            # Wait a bit for service to fully start
            sleep 5
            
            # Check container status
            if ! docker ps | grep -q mecabal-web-app; then
              echo "ERROR: Container is not running!"
              docker logs mecabal-web-app --tail 50
              exit 1
            fi
            
            # Health check
            if ! docker exec mecabal-web-app node -e "require('http').get('http://localhost:3015', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})" 2>/dev/null; then
              echo "ERROR: Health check failed!"
              docker logs mecabal-web-app --tail 50
              exit 1
            fi
            
            echo "Deployment verification successful!"

  # SSL Certificate Renewal (separate job, runs on schedule)
  ssl-renewal:
    name: SSL Certificate Renewal
    runs-on: ubuntu-latest
    # Only run on schedule or manual trigger (not on push/PR)
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Renew SSL certificates
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          port: ${{ secrets.PRODUCTION_SSH_PORT || 22 }}
          script: |
            set -e
            
            # Renew certificates for both domains
            echo "Renewing SSL certificates..."
            
            # Check if certbot container exists
            if docker ps -a | grep -q mecabal-certbot; then
              # Renew certificates using certbot container
              docker exec mecabal-certbot certbot renew --dry-run || \
                docker exec mecabal-certbot certbot renew
              
              # Reload nginx to use new certificates
              if docker ps -q -f name=mecabal-nginx >/dev/null 2>&1; then
                docker exec mecabal-nginx nginx -s reload
              fi
            else
              # Manual certbot renewal (if not using container)
              certbot renew --nginx || certbot renew
              systemctl reload nginx || service nginx reload
            fi
            
            echo "SSL certificate renewal completed!"

